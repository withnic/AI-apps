<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Splatoon 3 編成アナライザー</title>
    <style>
        /* --- 全体スタイル --- */
        :root {
            --bg-color: #f0f2f5;
            --main-text-color: #1a1a1a;
            --card-bg-color: #ffffff;
            --border-color: #e0e0e0;
            --primary-color: #28a745;
            --primary-hover-color: #218838;
            --secondary-color: #dc3545;
            --secondary-hover-color: #c82333;
            --info-color: #007bff;
            --info-hover-color: #0056b3;
            --warning-color: #ffc107;
            --warning-hover-color: #e0a800;
            --slot-border-color: #ccc;
            --slot-selected-border-color: #4CAF50;
            --font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "Segoe UI", "Hiragino Kaku Gothic ProN", "Hiragino Sans", "ヒラギノ角ゴ ProN W3", Arial, "メイリオ", Meiryo, sans-serif;
        }

        body { 
            font-family: var(--font-family);
            background-color: var(--bg-color); 
            color: var(--main-text-color); 
            margin: 0; 
            padding: 1rem;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* --- ヘッダー --- */
        header { 
            text-align: center; 
            margin-bottom: 2rem; 
            padding-bottom: 1rem;
        }
        h1 {
            color: #2c2c2c;
            font-weight: 700;
            font-size: 2rem;
        }

        /* --- メインコンテンツ --- */
        main {
            max-width: 1200px;
            margin: 0 auto;
        }
        .setup-area { 
            display: flex; 
            flex-wrap: wrap;
            justify-content: center; 
            gap: 1rem; 
            margin-bottom: 2rem; 
        }
        .setup-area select {
            padding: 0.75rem;
            font-size: 1rem;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        /* --- チーム編成エリア --- */
        .teams-area { 
            display: flex; 
            flex-direction: column;
            justify-content: center; 
            align-items: center; 
            gap: 1.5rem;
        }
        @media (min-width: 768px) {
            .teams-area {
                flex-direction: row;
                align-items: flex-start;
            }
        }
        .team-container { 
            background: var(--card-bg-color); 
            padding: 1.5rem; 
            border-radius: 12px; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.08); 
            text-align: center; 
            width: 100%;
            max-width: 500px;
        }
        .weapon-slots { 
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.75rem; 
            margin-top: 1rem; 
        }
        .weapon-slot { 
            width: 100%;
            aspect-ratio: 1 / 1;
            border: 2px dashed var(--slot-border-color); 
            border-radius: 8px; 
            display: flex; 
            flex-direction: column;
            justify-content: center; 
            align-items: center; 
            font-size: 2rem; 
            color: var(--slot-border-color); 
            cursor: pointer; 
            background-size: 75%; 
            background-position: center 35%;
            background-repeat: no-repeat;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            position: relative;
        }
        .weapon-slot:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .weapon-slot.selected { 
            border-style: solid;
            border-color: var(--slot-selected-border-color);
            color: transparent; 
        }
        .weapon-name {
            position: absolute;
            bottom: 5px;
            left: 0;
            right: 0;
            font-size: 11px;
            font-weight: bold;
            color: #fff;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 2px 0;
            text-align: center;
            border-bottom-left-radius: 6px;
            border-bottom-right-radius: 6px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding: 3px 2px;
        }
        .vs { 
            font-size: 2rem; 
            font-weight: bold; 
            color: #555;
            margin-top: 2rem;
            transform: rotate(-10deg);
        }
        
        /* --- ボタンエリア --- */
        .action-area {
            display: flex; 
            flex-wrap: wrap;
            justify-content: center; 
            gap: 1rem; 
            margin-top: 2rem; 
            padding: 1rem;
            background: var(--card-bg-color);
            border-radius: 12px;
        }
        .action-area button, .action-area label { 
            padding: 0.75rem 1.5rem; 
            font-size: 1rem; 
            font-weight: bold;
            cursor: pointer; 
            border-radius: 8px; 
            border: none; 
            transition: background-color 0.2s ease, transform 0.2s ease;
            display: inline-block;
            text-align: center;
        }
        #analyze-button { 
            background-color: var(--primary-color); 
            color: white; 
        }
        #analyze-button:hover {
            background-color: var(--primary-hover-color);
            transform: translateY(-2px);
        }
        #save-button, #load-label {
             background-color: var(--info-color);
             color: white;
        }
        #save-button:hover, #load-label:hover {
             background-color: var(--info-hover-color);
             transform: translateY(-2px);
        }
        #reset-button { 
            background-color: var(--secondary-color); 
            color: white; 
        }
        #reset-button:hover {
            background-color: var(--secondary-hover-color);
            transform: translateY(-2px);
        }
        #load-input {
            display: none;
        }
        
        /* --- データ設定エリア --- */
        .data-settings {
            background: #e9ecef;
            padding: 1rem;
            margin: 2rem 0;
            border-radius: 12px;
        }
        .data-settings summary {
            font-weight: bold;
            cursor: pointer;
        }
        .data-upload-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }
        .data-upload-grid label {
            background: #fff;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            text-align: center;
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .data-upload-grid label:hover {
            background-color: #f8f9fa;
        }
        .data-upload-grid input[type="file"] {
            display: none;
        }
        .data-settings-footer {
            margin-top: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }
        .data-settings-note {
            font-size: 0.8em;
            color: #6c757d;
        }
        #clear-settings-button {
            background-color: var(--warning-color);
            color: black;
            padding: 0.5rem 1rem;
        }
        #clear-settings-button:hover {
            background-color: var(--warning-hover-color);
        }


        /* --- 結果表示エリア --- */
        #analysis-history-container {
            margin-top: 2rem;
        }
        .analysis-card {
            background: var(--card-bg-color);
            margin-bottom: 1.5rem;
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            position: relative;
        }
        .analysis-card h3 {
            margin-top: 0;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 0.5rem;
            display: inline-block;
        }
        .result-compositions {
            display: flex;
            justify-content: space-around;
            gap: 1rem;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
        }
        .result-team-comp {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            min-width: 200px;
        }
        .result-weapon {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .result-weapon img {
            width: 24px;
            height: 24px;
        }
        .result-section {
            text-align: left;
            margin-bottom: 1.5rem;
        }
        .result-section h4 {
            margin-bottom: 0.5rem;
            color: #333;
        }
        .result-section p, .result-section ul {
            margin-top: 0;
            line-height: 1.6;
        }
        .result-section ul {
            padding-left: 20px;
        }
        .advantage-bar {
            width: 100%;
            background-color: #ddd;
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            height: 30px;
            font-weight: bold;
            color: white;
            margin: 1rem 0;
        }
        .my-team-bar, .enemy-team-bar {
            display: flex;
            align-items: center;
            justify-content: center;
            transition: width 0.5s ease-in-out;
        }
        .my-team-bar { background-color: #007bff; }
        .enemy-team-bar { background-color: #ff4136; }

        .delete-card-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #ddd;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            line-height: 30px;
            text-align: center;
        }
        .delete-card-btn:hover { background: #bbb; }

        /* 目標数値テーブル */
        .targets-container { overflow-x: auto; }
        .targets-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            min-width: 600px; /* 列追加のため拡張 */
        }
        .targets-table th, .targets-table td {
            border: 1px solid var(--border-color);
            padding: 8px;
            text-align: center;
        }
        .targets-table th { background-color: #f8f9fa; }
        .targets-table td:first-child { text-align: left; font-weight: bold; }
        .targets-table tfoot td {
            font-weight: bold;
            background-color: #f8f9fa;
        }

        /* --- ブキ選択モーダル --- */
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); backdrop-filter: blur(5px); }
        .modal-content { background-color: #fefefe; margin: 5% auto; padding: 20px; border: 1px solid #888; width: 90%; max-width: 800px; border-radius: 12px; animation: fadeIn 0.3s ease; }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
        .close-button { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
        #weapon-search { width: 100%; padding: 12px; margin-bottom: 20px; box-sizing: border-box; font-size: 1rem; border-radius: 8px; border: 1px solid var(--slot-border-color); }
        #weapon-list { display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 1rem; max-height: 60vh; overflow-y: auto; }
        .weapon-item { display: flex; flex-direction: column; align-items: center; cursor: pointer; padding: 10px 5px; border-radius: 8px; transition: background-color 0.2s ease; }
        .weapon-item:hover { background-color: #e9e9e9; }
        .weapon-item img { width: 72px; height: 72px; pointer-events: none; }
        .weapon-item span { font-size: 12px; text-align: center; margin-top: 5px; pointer-events: none; }
    </style>
</head>
<body>
    <header>
        <h1>Splatoon 3 編成アナライザー</h1>
    </header>
    <main>
        <div class="setup-area">
            <select id="stage-select"></select>
            <select id="rule-select">
                <option value="nawabari">ナワバリバトル</option>
                <option value="area">ガチエリア</option>
                <option value="yagura">ガチヤグラ</option>
                <option value="hoko">ガチホコバトル</option>
                <option value="asari">ガチアサリ</option>
            </select>
        </div>
        <div class="teams-area">
            <div class="team-container" id="my-team-container">
                <h2>自チーム</h2>
                <div class="weapon-slots">
                    <div class="weapon-slot" data-team="my" data-player="1">+<span class="weapon-name"></span></div>
                    <div class="weapon-slot" data-team="my" data-player="2">+<span class="weapon-name"></span></div>
                    <div class="weapon-slot" data-team="my" data-player="3">+<span class="weapon-name"></span></div>
                    <div class="weapon-slot" data-team="my" data-player="4">+<span class="weapon-name"></span></div>
                </div>
            </div>
            <div class="vs">VS</div>
            <div class="team-container" id="enemy-team-container">
                <h2>相手チーム</h2>
                <div class="weapon-slots">
                    <div class="weapon-slot" data-team="enemy" data-player="1">+<span class="weapon-name"></span></div>
                    <div class="weapon-slot" data-team="enemy" data-player="2">+<span class="weapon-name"></span></div>
                    <div class="weapon-slot" data-team="enemy" data-player="3">+<span class="weapon-name"></span></div>
                    <div class="weapon-slot" data-team="enemy" data-player="4">+<span class="weapon-name"></span></div>
                </div>
            </div>
        </div>
        <div class="action-area">
            <button id="analyze-button">分析して結果を追加</button>
            <button id="save-button">この編成を保存</button>
            <label for="load-input" id="load-label">編成を読込</label>
            <input type="file" id="load-input" accept=".json">
            <button id="reset-button">リセット</button>
        </div>
        
        <details class="data-settings">
            <summary>データ設定 (JSONファイルで上書き)</summary>
            <div class="data-upload-grid">
                <label for="load-stages-data">ステージリスト上書き</label>
                <input type="file" id="load-stages-data" accept=".json">
                <label for="load-weapons-data">ブキデータ上書き</label>
                <input type="file" id="load-weapons-data" accept=".json">
                <label for="load-tiers-data">ティア表上書き</label>
                <input type="file" id="load-tiers-data" accept=".json">
                <label for="load-counters-data">カウンター相性上書き</label>
                <input type="file" id="load-counters-data" accept=".json">
                <label for="load-specials-data">スペシャルタグ上書き</label>
                <input type="file" id="load-specials-data" accept=".json">
                <label for="load-roles-data">役割データ上書き</label>
                <input type="file" id="load-roles-data" accept=".json">
            </div>
            <div class="data-settings-footer">
                <p class="data-settings-note">※アップロードしたデータはブラウザに保存され、次回以降も自動で読み込まれます。</p>
                <button id="clear-settings-button">保存した設定をリセット</button>
            </div>
        </details>

        <div id="analysis-history-container">
            <!-- 分析結果カードがここに追加される -->
        </div>
    </main>

    <!-- ブキ選択モーダル -->
    <div id="weapon-modal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h3>ブキを選択</h3>
            <input type="text" id="weapon-search" placeholder="ブキ名で検索 (例: スシ、わかば)">
            <div id="weapon-list"></div>
        </div>
    </div>

<script>
// --- ここからJavaScript ---

// =================================================================================
// ★★★ 分析ロジックのコアデータ ★★★
// =================================================================================
let DEFAULT_WEAPONS = [
    { "name": "わかばシューター", "type": "シューター", "range": 27, "sub": "スプラッシュボム", "special": "グレートバリア", "specialPoints": 200, "img": "https://placehold.co/96x96/90ee90/000000?text=WAKABA" },
    { "name": "スプラシューター", "type": "シューター", "range": 50, "sub": "キューバンボム", "special": "ウルトラショット", "specialPoints": 200, "img": "https://placehold.co/96x96/4682b4/ffffff?text=SPLAT_S" },
    { "name": "スプラローラー", "type": "ローラー", "range": 45, "sub": "カーリングボム", "special": "グレートバリア", "specialPoints": 190, "img": "https://placehold.co/96x96/66cdaa/000000?text=ROLLER" },
    { "name": "リッター4K", "type": "チャージャー", "range": 100, "sub": "ホップソナー", "special": "テイオウイカ", "specialPoints": 210, "img": "https://placehold.co/96x96/8b0000/ffffff?text=LITER" },
    { "name": "ハイドラント", "type": "スピナー", "range": 90, "sub": "ロボットボム", "special": "ナイスダマ", "specialPoints": 210, "img": "https://placehold.co/96x96/ffa500/000000?text=HYDRA" }
];
let WEAPONS = [...DEFAULT_WEAPONS];

let DEFAULT_SPECIAL_TAGS = {"グレートバリア": ["抑え"],"ホップソナー": ["抑え"],"カニタンク": ["打開", "キル", "抑え"],"トリプルトルネード": ["打開", "抑え"],"サメライド": ["打開", "キル"],"ナイスダマ": ["打開", "キル"],"ウルトラショット": ["打開", "キル"],"メガホンレーザー5.1ch": ["打開", "キル"],"エナジースタンド": ["抑え"],"デコイチラシ": ["抑え"],"ウルトラハンコ": ["打開", "キル"],"キューインキ": ["抑え"],"アメフラシ": ["打開", "抑え"],"マルチミサイル": ["打開", "抑え"],"ショクワンダー": ["打開", "キル"],"テイオウイカ": ["打開", "キル"],"スミナガシート": ["抑え"],"ジェットパック": ["打開", "キル"],"ウルトラチャクチ": ["打開", "キル"]};
let SPECIAL_TAGS = {...DEFAULT_SPECIAL_TAGS};

let DEFAULT_COUNTER_MATCHUPS = [{"winner": "リッター","loser": "ハイドラント","score": 8,"description": "リッターはハイドラントに対して有利な射程を持っています。"},{"winner": "エクスプロッシャー","loser": "カニタンク","score": 6,"description": "エクスプロッシャーはカニタンクに対して効果的にダメージを与えられます。"}];
let COUNTER_MATCHUPS = [...DEFAULT_COUNTER_MATCHUPS];

const TIER_SCORES = {tierX: 15,tierS: 10,tierA: 7,tierB: 4,tierC: 1};

let DEFAULT_WEAPON_TIERS_BY_RULE = {"nawabari": {"tierX": ["シャープマーカーネオ"],"tierS": ["わかばシューター", "プロモデラーRG"],"tierA": ["LACT-450", "スプラシューター"],"tierB": ["スプラローラー", "ワイドローラー"],"tierC": ["リッター4K"]},"area": {"tierX": ["リッター4K"],"tierS": ["シャープマーカーネオ", "H3リールガンD"],"tierA": ["スプラシューターコラボ", "エクスプロッシャー", "LACT-450"],"tierB": ["わかばシューター", "バケットスロッシャー"],"tierC": ["カーボンローラー"]},"yagura": {"tierX": [],"tierS": ["ラピッドブラスター", "クーゲルシュライバー", "ジェットスイーパーカスタム"],"tierA": ["リッター4K", "ホットブラスター", ".96ガロン"],"tierB": ["スプラシューター", "キャンプシェルター"],"tierC": ["パブロ"]},"hoko": {"tierX": [],"tierS": ["スプラシューター", "H3リールガン", "エクスプロッシャーカスタム"],"tierA": [".52ガロン", "ジムワイパー", "ワイドローラー"],"tierB": ["N-ZAP85", "スプラローラー"],"tierC": ["ソイチューバー"]},"asari": {"tierX": [],"tierS": ["シャープマーカー", "スクリュースロッシャー", "N-ZAP85"],"tierA": ["スプラマニューバー", "わかばシューター", "オーバーフロッシャー"],"tierB": ["ボールドマーカー", "ホクサイ"],"tierC": ["リッター4K"]}};
let WEAPON_TIERS_BY_RULE = {...DEFAULT_WEAPON_TIERS_BY_RULE};

let DEFAULT_STAGES = [{"value": "yagara","name": "ヤガラ市場"},{"value": "gonzui","name": "ゴンズイ地区"},{"value": "yunohana","name": "ユノハナ大渓谷"},{"value": "mategai","name": "マテガイ放水路"},{"value": "ama","name": "海女美術大学"},{"value": "chouzame","name": "チョウザメ造船"},{"value": "zatou","name": "ザトウマーケット"},{"value": "sumeshi","name": "スメーシーワールド"},{"value": "kusaya","name": "クサヤ温泉"},{"value": "hirame","name": "ヒラメが丘団地"},{"value": "nampula","name": "ナンプラー遺跡"},{"value": "kinmedai","name": "キンメダイ美術館"},{"value": "mahimahi","name": "マヒマヒリゾート＆スパ"},{"value": "masaba","name": "マサバ海峡大橋"},{"value": "taraport","name": "タラポートショッピングパーク"},{"value": "kombu","name": "コンブトラック"},{"value": "manta","name": "マンタマリア号"},{"value": "negitoro","name": "ネギトロ炭鉱"},{"value": "bangaitei","name": "バイガイ亭"},{"value": "takaashi","name": "タカアシ経済特区"},{"value": "ohyou","name": "オヒョウ海運"},{"value": "namero","name": "ナメロウ金属"},{"value": "kajibaguru","name": "カジキ空港"},{"value": "dekaline","name": "デカライン高架下"}];

let DEFAULT_ROLE_PRIORITIES = [{"name": "わかばシューター","後衛アンカー": 27,"かく乱": 80,"塗り": 100,"前衛アタッカー": 72,"中衛サポート": 0, "中衛スイーパー": 67},{"name": "スプラシューター","後衛アンカー": 50,"かく乱": 34,"塗り": 0,"前衛アタッカー": 95,"中衛サポート": 0, "中衛スイーパー": 90},{"name": "スプラローラー","後衛アンカー": 45,"かく乱": 100,"塗り": 0,"前衛アタッカー": 90,"中衛サポート": 0, "中衛スイーパー": 85},{"name": "リッター4K","後衛アンカー": 100,"かく乱": 0,"塗り": 0,"前衛アタッカー": 55,"中衛サポート": 0, "中衛スイーパー": 60},{"name": "ハイドラント","後衛アンカー": 90,"かく乱": 0,"塗り": 0,"前衛アタッカー": 65,"中衛サポート": 0, "中衛スイーパー": 70}];
let ROLE_PRIORITIES = [...DEFAULT_ROLE_PRIORITIES];

// --- IndexedDB ---
const DB_NAME = 'SplatoonAnalyzerDB';
const STORE_NAME = 'spla3_team_settings'; 
let db;

function initDB() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, 2); 
        request.onerror = event => reject("DB Error: " + event.target.errorCode);
        request.onsuccess = event => {
            db = event.target.result;
            resolve(db);
        };
        request.onupgradeneeded = event => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(STORE_NAME)) {
                db.createObjectStore(STORE_NAME, { keyPath: 'id' });
            }
        };
    });
}

function saveData(id, data) {
    return new Promise((resolve, reject) => {
        if (!db) return reject("DB not initialized");
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.put({ id, data });
        request.onsuccess = () => resolve();
        request.onerror = event => reject("Save Error: " + event.target.errorCode);
    });
}

function loadData(id) {
    return new Promise((resolve, reject) => {
        if (!db) return reject("DB not initialized");
        const transaction = db.transaction([STORE_NAME]);
        const store = transaction.objectStore(STORE_NAME);
        const request = store.get(id);
        request.onsuccess = event => resolve(event.target.result ? event.target.result.data : null);
        request.onerror = event => reject("Load Error: " + event.target.errorCode);
    });
}

function clearDB() {
    return new Promise((resolve, reject) => {
        if (!db) return reject("DB not initialized");
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.clear();
        request.onsuccess = () => resolve();
        request.onerror = event => reject("Clear Error: " + event.target.errorCode);
    });
}

// --- App Logic ---
document.addEventListener('DOMContentLoaded', async () => {
    // DB初期化とデータ読み込み
    try {
        await initDB();
        const loadedWeapons = await loadData('weapons');
        if (loadedWeapons) WEAPONS = loadedWeapons;
        const loadedTiers = await loadData('tiers');
        if (loadedTiers) WEAPON_TIERS_BY_RULE = loadedTiers;
        const loadedCounters = await loadData('counters');
        if (loadedCounters) COUNTER_MATCHUPS = loadedCounters;
        const loadedSpecials = await loadData('specials');
        if (loadedSpecials) SPECIAL_TAGS = loadedSpecials;
        const loadedStages = await loadData('stages');
        if (loadedStages) DEFAULT_STAGES = loadedStages;
        const loadedRoles = await loadData('roles');
        if (loadedRoles) ROLE_PRIORITIES = loadedRoles;

    } catch (e) {
        console.error("IndexedDBの初期化または読み込みに失敗しました。", e);
    }

    // DOM要素の取得
    const weaponSlots = document.querySelectorAll('.weapon-slot');
    const modal = document.getElementById('weapon-modal');
    const closeButton = document.querySelector('.close-button');
    const weaponList = document.getElementById('weapon-list');
    const searchInput = document.getElementById('weapon-search');
    const analyzeButton = document.getElementById('analyze-button');
    const resetButton = document.getElementById('reset-button');
    const saveButton = document.getElementById('save-button');
    const loadInput = document.getElementById('load-input');
    const analysisHistoryContainer = document.getElementById('analysis-history-container');
    const stageSelect = document.getElementById('stage-select');
    const clearSettingsButton = document.getElementById('clear-settings-button');
    
    // データアップロード用Input
    const loadWeaponsDataInput = document.getElementById('load-weapons-data');
    const loadTiersDataInput = document.getElementById('load-tiers-data');
    const loadCountersDataInput = document.getElementById('load-counters-data');
    const loadSpecialsDataInput = document.getElementById('load-specials-data');
    const loadStagesDataInput = document.getElementById('load-stages-data');
    const loadRolesDataInput = document.getElementById('load-roles-data');
    
    // アプリの状態を管理する変数
    let currentSlot = null;
    let selectedWeapons = { 
        my: {1: null, 2: null, 3: null, 4: null}, 
        enemy: {1: null, 2: null, 3: null, 4: null} 
    };
    let analysisHistory = [];

    // ステージリストの描画
    function renderStageList(stages) {
        stageSelect.innerHTML = '';
        stages.forEach(stage => {
            const option = document.createElement('option');
            option.value = stage.value;
            option.textContent = stage.name;
            stageSelect.appendChild(option);
        });
    }

    /**
     * ブキリストをモーダル内に描画する関数
     */
    function renderWeaponList(filter = '') {
        weaponList.innerHTML = '';
        const lowerCaseFilter = filter.toLowerCase();
        WEAPONS
            .filter(weapon => weapon.name.toLowerCase().includes(lowerCaseFilter))
            .forEach(weapon => {
                const item = document.createElement('div');
                item.className = 'weapon-item';
                item.dataset.weaponName = weapon.name; 
                
                const img = document.createElement('img');
                img.src = weapon.img;
                img.alt = weapon.name;
                img.onerror = () => { img.src = `https://placehold.co/96x96/f0f2f5/ccc?text=Error`; };

                const name = document.createElement('span');
                name.textContent = weapon.name;

                item.appendChild(img);
                item.appendChild(name);
                weaponList.appendChild(item);
            });
    }

    weaponSlots.forEach(slot => {
        slot.addEventListener('click', () => {
            currentSlot = slot;
            renderWeaponList(searchInput.value);
            modal.style.display = 'block';
            searchInput.focus();
        });
    });

    closeButton.addEventListener('click', () => modal.style.display = 'none');
    window.addEventListener('click', (event) => {
        if (event.target == modal) {
            modal.style.display = 'none';
        }
    });

    searchInput.addEventListener('input', () => renderWeaponList(searchInput.value));

    weaponList.addEventListener('click', (event) => {
        const item = event.target.closest('.weapon-item');
        if (item && currentSlot) {
            const weaponName = item.dataset.weaponName;
            const selectedWeapon = WEAPONS.find(w => w.name === weaponName);
            
            if (selectedWeapon) {
                updateSlotUI(currentSlot, selectedWeapon);
                const { team, player } = currentSlot.dataset;
                selectedWeapons[team][player] = selectedWeapon;
                modal.style.display = 'none';
            }
        }
    });

    function updateSlotUI(slot, weapon) {
        slot.style.backgroundImage = `url('${weapon.img}')`;
        slot.querySelector('.weapon-name').textContent = weapon.name;
        slot.classList.add('selected');
    }

    // --- 分析ロジック ---
    const ROLE_ORDER = ["後衛アンカー", "かく乱", "塗り", "中衛スイーパー", "前衛アタッカー", "中衛サポート"];
    const defaultPriorities = ROLE_ORDER.reduce((acc, role) => ({ ...acc, [role]: 0 }), {});

    function assignInherentRole(weapon) {
        const priorities = ROLE_PRIORITIES.find(p => p.name === weapon.name) || {};
        let maxPriority = -1;
        let bestRole = "中衛サポート";
        ROLE_ORDER.forEach(role => {
             const currentPriority = priorities[role] || 0;
             if (currentPriority > maxPriority) {
                maxPriority = currentPriority;
                bestRole = role;
            }
        });
        return { role: bestRole, score: maxPriority };
    }

    function assignRolesByPriority(teamWeapons) {
        const players = teamWeapons.map((weapon, index) => ({
            weapon,
            priorities: ROLE_PRIORITIES.find(p => p.name === weapon.name) || { ...defaultPriorities },
            originalIndex: index,
        }));
    
        function getPermutations(arr) {
            if (arr.length === 0) return [[]];
            const firstEl = arr[0];
            const rest = arr.slice(1);
            const permsWithoutFirst = getPermutations(rest);
            const allPermutations = [];
            permsWithoutFirst.forEach(p => {
                for (let i = 0; i <= p.length; i++) {
                    const perm = [...p.slice(0, i), firstEl, ...p.slice(i)];
                    allPermutations.push(perm);
                }
            });
            return allPermutations;
        }

        const playerIndices = [0, 1, 2, 3];
        const roleIndices = [0, 1, 2, 3, 4, 5];
        
        let bestAssignment = new Array(4).fill({ role: '未定', score: 0 });
        let maxScore = -1;
        
        const roleCombinations = getPermutations(roleIndices).map(p => p.slice(0, 4));

        roleCombinations.forEach(roleCombinationIndices => {
            const roles = roleCombinationIndices.map(i => ROLE_ORDER[i]);
            const playerPermutations = getPermutations(playerIndices);

            playerPermutations.forEach(playerOrder => {
                let currentScore = 0;
                let currentAssignment = new Array(4);
                let isValid = true;
                
                playerOrder.forEach((playerIndex, i) => {
                    const role = roles[i];
                    if (!role) {
                        isValid = false;
                        return;
                    }
                    const score = players[playerIndex].priorities[role] || 0;
                    currentScore += score;
                    currentAssignment[playerIndex] = { role, score };
                });
                
                if (isValid && currentScore > maxScore) {
                    maxScore = currentScore;
                    bestAssignment = currentAssignment;
                }
            });
        });

        const finalAssignment = new Array(4);
        players.forEach((p, i) => {
             finalAssignment[p.originalIndex] = bestAssignment[i];
        });

        return finalAssignment;
    }


    function getRoleBalanceScore(roles) {
        const roleSet = new Set(roles.map(r => r.role));
        let score = 10;
        if (!roleSet.has("後衛アンカー")) score -= 3;
        if (!roleSet.has("前衛アタッカー") && !roleSet.has("かく乱")) score -= 5;
        if (!roleSet.has("塗り")) score -= 2;
        return Math.max(0, score);
    }

    function getSynergyScore(teamWeapons) {
        let score = 0;
        const specials = teamWeapons.map(w => w.special);
        if (specials.includes("エナジースタンド") && teamWeapons.some(w => assignInherentRole(w).role === "前衛アタッカー" || assignInherentRole(w).role === "かく乱")) score += 5;
        if (specials.includes("ホップソナー") && teamWeapons.some(w => assignInherentRole(w).role === "後衛アンカー")) score += 5;
        return score;
    }

    function getMatchupScore(myTeamWeapons, enemyTeamWeapons) {
        let myScore = 0, enemyScore = 0;
        let descriptions = [];
        const myWeaponNames = myTeamWeapons.map(w => w.name);
        const mySpecialNames = myTeamWeapons.map(w => w.special);
        const enemyWeaponNames = enemyTeamWeapons.map(w => w.name);
        const enemySpecialNames = enemyTeamWeapons.map(w => w.special);

        COUNTER_MATCHUPS.forEach(matchup => {
            const myHasWinner = myWeaponNames.some(name => name.includes(matchup.winner)) || mySpecialNames.some(name => name.includes(matchup.winner));
            const myHasLoser = myWeaponNames.some(name => name.includes(matchup.loser)) || mySpecialNames.some(name => name.includes(matchup.loser));
            const enemyHasWinner = enemyWeaponNames.some(name => name.includes(matchup.winner)) || enemySpecialNames.some(name => name.includes(matchup.winner));
            const enemyHasLoser = enemyWeaponNames.some(name => name.includes(matchup.loser)) || enemySpecialNames.some(name => name.includes(matchup.loser));

            if (myHasWinner && enemyHasLoser) {
                myScore += matchup.score;
                descriptions.push(`[自チーム有利] ${matchup.description}`);
            }
            if (enemyHasWinner && myHasLoser) {
                enemyScore += matchup.score;
                descriptions.push(`[相手チーム有利] ${matchup.description}`);
            }
        });
        return { myScore, enemyScore, descriptions };
    }

    function getSpecialCompositionScore(teamWeapons) {
        const tagCounts = { "打開": 0, "抑え": 0, "キル": 0 };
        let score = 0;
        teamWeapons.forEach(weapon => {
            const tags = SPECIAL_TAGS[weapon.special] || [];
            tags.forEach(tag => { tagCounts[tag]++; });
        });

        if (tagCounts["打開"] === 0) score -= 10;
        else if (tagCounts["打開"] >= 2) score += 8;
        else score += 4;
        
        if (tagCounts["抑え"] >= 2) score += 6;
        else if (tagCounts["抑え"] === 1) score += 2;

        return { score, tagCounts };
    }

    function getWeaponTier(weaponName, rule) {
        const tiers = WEAPON_TIERS_BY_RULE[rule];
        if (!tiers) return "C";
        if (tiers.tierX && tiers.tierX.includes(weaponName)) return "X";
        if (tiers.tierS && tiers.tierS.includes(weaponName)) return "S";
        if (tiers.tierA && tiers.tierA.includes(weaponName)) return "A";
        if (tiers.tierB && tiers.tierB.includes(weaponName)) return "B";
        return "C";
    }
    
    function getTierScore(teamWeapons, rule) {
        let score = 0;
        teamWeapons.forEach(weapon => {
            const tier = getWeaponTier(weapon.name, rule);
            switch (tier) {
                case "X": score += TIER_SCORES.tierX; break;
                case "S": score += TIER_SCORES.tierS; break;
                case "A": score += TIER_SCORES.tierA; break;
                case "B": score += TIER_SCORES.tierB; break;
                default: score += TIER_SCORES.tierC; break;
            }
        });
        return score;
    }
    
    function calculateTargets(weapon, role) {
        let targets = { kill: 10, death: 8, paint: 1000, sp: 6 };
        const roleMap = {
            "前衛アタッカー": { kill: 1.2, death: 1.1, paint: 0.8, sp: 1.0 },
            "中衛サポート": { kill: 1.0, death: 1.0, paint: 1.0, sp: 1.0 },
            "後衛アンカー": { kill: 1.3, death: 0.7, paint: 0.7, sp: 0.9 },
            "塗り": { kill: 0.7, death: 1.0, paint: 1.5, sp: 1.2 },
            "かく乱": { kill: 1.1, death: 1.2, paint: 0.9, sp: 1.1 },
            "中衛スイーパー": { kill: 1.1, death: 0.9, paint: 1.1, sp: 1.0 },
        };
        const multipliers = roleMap[role] || roleMap["中衛サポート"];
        return {
            kill: Math.round(targets.kill * multipliers.kill),
            death: Math.round(targets.death * multipliers.death),
            paint: Math.round(targets.paint * multipliers.paint),
            sp: Math.round(targets.sp * multipliers.sp)
        };
    }

    analyzeButton.addEventListener('click', () => {
        const myTeamWeapons = Object.values(selectedWeapons.my);
        const enemyTeamWeapons = Object.values(selectedWeapons.enemy);

        if (myTeamWeapons.includes(null) || enemyTeamWeapons.includes(null)) {
            alert('両チームのブキを4つずつ選択してください。');
            return;
        }

        const stage = document.getElementById('stage-select').value;
        const rule = document.getElementById('rule-select').value;

        const analyzeTeam = (teamWeapons, currentRule) => {
            const avgRange = teamWeapons.reduce((sum, w) => sum + w.range, 0) / 4;
            const inherentRoles = teamWeapons.map(weapon => assignInherentRole(weapon));
            const compRoles = assignRolesByPriority(teamWeapons);
            const compRoleTotalScore = compRoles.reduce((sum, roleInfo) => sum + (roleInfo.score || 0), 0);
            const paintScore = teamWeapons.reduce((score, w) => {
                if (w.name.includes("わかば") || w.name.includes("プロモデラー")) return score + 3;
                if (w.type === "シューター" || w.type === "ローラー" || w.type === "フデ") return score + 2;
                return score + 1;
            }, 0);
            const balanceScore = getRoleBalanceScore(compRoles.map(r => r.role));
            const synergyScore = getSynergyScore(teamWeapons);
            const specialComp = getSpecialCompositionScore(teamWeapons);
            const tierScore = getTierScore(teamWeapons, currentRule);
            
            const totalScore = (avgRange * 0.4) + (paintScore * 2) + (balanceScore * 1.5) + synergyScore + specialComp.score + tierScore;
            const weaponTiers = teamWeapons.map(w => getWeaponTier(w.name, currentRule));
            return { totalScore, avgRange, paintScore, balanceScore, synergyScore, specialComp, tierScore, inherentRoles, compRoles, compRoleTotalScore, weapons: teamWeapons, weaponTiers };
        };

        const myTeamAnalysis = analyzeTeam(myTeamWeapons, rule);
        const enemyTeamAnalysis = analyzeTeam(enemyTeamWeapons, rule);
        const matchupScores = getMatchupScore(myTeamWeapons, enemyTeamWeapons);

        let myTotalScore = myTeamAnalysis.totalScore + matchupScores.myScore;
        let enemyTotalScore = enemyTeamAnalysis.totalScore + matchupScores.enemyScore;

        const totalScoreSum = myTotalScore + enemyTotalScore;
        const myAdvPercentage = totalScoreSum > 0 ? Math.round((myTotalScore / totalScoreSum) * 100) : 50;
        const enemyAdvPercentage = 100 - myAdvPercentage;
        
        const resultData = {
            stage,
            rule,
            myTeamAnalysis,
            enemyTeamAnalysis,
            matchupScores,
            myAdvPercentage,
            enemyAdvPercentage,
            myTeamWeapons: myTeamWeapons.map(w => ({name: w.name, img: w.img})),
            enemyTeamWeapons: enemyTeamWeapons.map(w => ({name: w.name, img: w.img}))
        };
        analysisHistory.unshift(resultData);
        renderAnalysisHistory();
    });

    function renderAnalysisHistory() {
        analysisHistoryContainer.innerHTML = '';
        analysisHistory.forEach((result, index) => {
            const card = document.createElement('div');
            card.className = 'analysis-card';
            card.dataset.index = index;

            const { stage, rule, myTeamAnalysis, enemyTeamAnalysis, matchupScores, myAdvPercentage, enemyAdvPercentage, myTeamWeapons, enemyTeamWeapons } = result;
            const stageText = document.querySelector(`#stage-select option[value="${stage}"]`)?.textContent || stage;
            const ruleText = document.querySelector(`#rule-select option[value="${rule}"]`)?.textContent || rule;

            let summary = "";
            if (myAdvPercentage > 55) summary = "総合的に自チームが有利です。編成バランスやカウンター相性で優位に立っています。";
            else if (myAdvPercentage < 45) summary = "総合的に相手チームが有利です。相手のカウンターやスペシャル構成に注意が必要です。";
            else summary = "両チームの力は互角です。個々のプレイヤースキルと連携が勝敗を分けるでしょう。";
            
            const tierDetailsHTML = `
                <div style="display: flex; justify-content: space-around; font-size: 0.9em; padding-top: 0.5rem;">
                    <div><b>自チーム</b><ul style="margin: 0; padding-left: 20px;">${myTeamAnalysis.weapons.map((w,i) => `<li>${w.name}: <b>${myTeamAnalysis.weaponTiers[i]}</b></li>`).join('')}</ul></div>
                    <div><b>相手チーム</b><ul style="margin: 0; padding-left: 20px;">${enemyTeamAnalysis.weapons.map((w,i) => `<li>${w.name}: <b>${enemyTeamAnalysis.weaponTiers[i]}</b></li>`).join('')}</ul></div>
                </div>`;

            let details = `<ul>
                    <li><b>平均射程:</b> 自チーム(${myTeamAnalysis.avgRange.toFixed(1)}) vs 相手チーム(${enemyTeamAnalysis.avgRange.toFixed(1)})</li>
                    <li><b>塗り性能スコア:</b> 自チーム(${myTeamAnalysis.paintScore}) vs 相手チーム(${enemyTeamAnalysis.paintScore})</li>
                    <li><b>役割バランススコア:</b> 自チーム(${myTeamAnalysis.balanceScore}/10) vs 相手チーム(${enemyTeamAnalysis.balanceScore}/10)</li>
                    <li><b>スペシャル構成スコア:</b> 自チーム(${myTeamAnalysis.specialComp.score}) vs 相手チーム(${enemyTeamAnalysis.specialComp.score}) <br>
                        <small><b>自:</b> ${myTeamAnalysis.weapons.map(w => w.special).join(', ')} (打開x${myTeamAnalysis.specialComp.tagCounts['打開']}, 抑えx${myTeamAnalysis.specialComp.tagCounts['抑え']}, キルx${myTeamAnalysis.specialComp.tagCounts['キル']})</small><br>
                        <small><b>相:</b> ${enemyTeamAnalysis.weapons.map(w => w.special).join(', ')} (打開x${enemyTeamAnalysis.specialComp.tagCounts['打開']}, 抑えx${enemyTeamAnalysis.specialComp.tagCounts['抑え']}, キルx${enemyTeamAnalysis.specialComp.tagCounts['キル']})</small>
                    </li>
                    <li><b>ルール適性スコア (ティア評価):</b> 自チーム(${myTeamAnalysis.tierScore}) vs 相手チーム(${enemyTeamAnalysis.tierScore})
                        ${tierDetailsHTML}
                    </li>
                    <li><b>マッチアップ評価:</b> <ul>${matchupScores.descriptions.length > 0 ? matchupScores.descriptions.map(d => `<li>${d}</li>`).join('') : '<li>特筆すべき有利・不利なし</li>'}</ul></li>
                </ul>`;
            
            let strategy = `この構成では、自チームは${myTeamAnalysis.compRoles.map(r => r.role).join('、')}という役割分担が最適です。役割バランスを意識し、特に${myTeamAnalysis.balanceScore < 7 ? '不足している役割を全員でカバーする動きが' : 'それぞれの役割をしっかりこなすことが'}勝利への鍵です。`;
            if (matchupScores.descriptions.length > 0) {
                strategy += ' マッチアップの有利不利を活かした立ち回りを心がけましょう。';
            }
            
            let targetsTable = `<div class="targets-container"><table class="targets-table">
                <thead><tr><th>ブキ</th><th>本来の役割 (適正Pt)</th><th>構成での役割 (適正Pt)</th><th>キル</th><th>デス</th><th>塗りP</th><th>SP回数</th></tr></thead><tbody>`;
            myTeamAnalysis.weapons.forEach((weapon, i) => {
                const inherentRoleInfo = myTeamAnalysis.inherentRoles[i];
                const compRoleInfo = myTeamAnalysis.compRoles[i];
                const targets = calculateTargets(weapon, compRoleInfo.role);
                targetsTable += `<tr><td>${weapon.name}</td><td>${inherentRoleInfo.role} (${inherentRoleInfo.score})</td><td>${compRoleInfo.role} (${compRoleInfo.score})</td><td>${targets.kill}</td><td>${targets.death}</td><td>${targets.paint}</td><td>${targets.sp}</td></tr>`;
            });
            targetsTable += `</tbody><tfoot>
                <tr><td colspan="2"><b>本来の役割 合計適正ポイント</b></td><td colspan="5"><b>${myTeamAnalysis.inherentRoles.reduce((s,r) => s + r.score, 0)}</b></td></tr>
                <tr><td colspan="2"><b>構成での役割 合計適正ポイント</b></td><td colspan="5"><b>${myTeamAnalysis.compRoleTotalScore}</b></td></tr>
            </tfoot></table></div>`;

            let compHTML = `<div class="result-compositions">
                <div class="result-team-comp"><b>自チーム:</b> ${myTeamWeapons.map(w => `<div class="result-weapon"><img src="${w.img}" alt="${w.name}"><span>${w.name}</span></div>`).join('')}</div>
                <div class="result-team-comp"><b>相手チーム:</b> ${enemyTeamWeapons.map(w => `<div class="result-weapon"><img src="${w.img}" alt="${w.name}"><span>${w.name}</span></div>`).join('')}</div>
            </div>`;

            card.innerHTML = `
                <button class="delete-card-btn" title="この結果を削除">&times;</button>
                <h3>${stageText} - ${ruleText}</h3>
                ${compHTML}
                <div class="result-section">
                    <h4>総合相性</h4>
                    <div class="advantage-bar">
                        <div class="my-team-bar" style="width: ${myAdvPercentage}%">自チーム ${myAdvPercentage}%</div>
                        <div class="enemy-team-bar" style="width: ${enemyAdvPercentage}%">相手チーム ${enemyAdvPercentage}%</div>
                    </div>
                    <p>${summary}</p>
                </div>
                <div class="result-section">
                    <h4>項目別 詳細分析</h4>
                    ${details}
                </div>
                <div class="result-section">
                    <h4>自チームの目標</h4>
                    ${targetsTable}
                </div>
                <div class="result-section">
                    <h4>勝利へのプラン提案</h4>
                    <p>${strategy}</p>
                </div>
            `;
            analysisHistoryContainer.appendChild(card);
        });
    }

    analysisHistoryContainer.addEventListener('click', (e) => {
        if (e.target.classList.contains('delete-card-btn')) {
            const card = e.target.closest('.analysis-card');
            const historyIndex = parseInt(card.dataset.index, 10);
            analysisHistory.splice(historyIndex, 1);
            renderAnalysisHistory();
        }
    });
    
    // --- 保存・読込 機能 ---
    saveButton.addEventListener('click', () => {
        const myTeamCount = Object.values(selectedWeapons.my).filter(w => w).length;
        if (myTeamCount < 4) {
            alert('保存するには、少なくとも自チームのブキを4つ選択してください。');
            return;
        }
        
        const dataToSave = {
            stage: document.getElementById('stage-select').value,
            rule: document.getElementById('rule-select').value,
            my: Object.fromEntries(Object.entries(selectedWeapons.my).map(([k, v]) => [k, v ? v.name : null])),
            enemy: Object.fromEntries(Object.entries(selectedWeapons.enemy).map(([k, v]) => [k, v ? v.name : null]))
        };

        const dataStr = JSON.stringify(dataToSave, null, 2);
        const dataBlob = new Blob([dataStr], {type: "application/json"});
        const url = URL.createObjectURL(dataBlob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'splatoon_matchup.json';
        a.click();
        URL.revokeObjectURL(url);
    });

    loadInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const loadedData = JSON.parse(e.target.result);
                if (loadedData.my && loadedData.enemy) {
                    selectedWeapons = { my: {}, enemy: {} };
                    ['my', 'enemy'].forEach(team => {
                        Object.entries(loadedData[team]).forEach(([player, weaponName]) => {
                            const weapon = WEAPONS.find(w => w.name === weaponName);
                            selectedWeapons[team][player] = weapon || null;
                            const slot = document.querySelector(`.weapon-slot[data-team="${team}"][data-player="${player}"]`);
                            if(slot && weapon) updateSlotUI(slot, weapon);
                        });
                    });

                    document.getElementById('stage-select').value = loadedData.stage || 'mategai';
                    document.getElementById('rule-select').value = loadedData.rule || 'area';
                    
                    alert('編成を読み込みました。');
                } else {
                    alert('無効なファイル形式です。');
                }
            } catch (error) {
                alert('ファイルの読み込みに失敗しました。');
                console.error(error);
            }
        };
        reader.readAsText(file);
        event.target.value = '';
    });
    
    // --- データ上書き機能 ---
    function setupDataUploader(inputId, dataName, validator, callback) {
        document.getElementById(inputId).addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    if (validator(data)) {
                        callback(data);
                        alert(`${dataName} のデータを上書きしました。`);
                    } else {
                        alert(`無効な ${dataName} のファイル形式です。`);
                    }
                } catch(error) {
                    alert(`${dataName} の読み込みに失敗しました。`);
                    console.error(error);
                }
                event.target.value = '';
            };
            reader.readAsText(file);
        });
    }

    setupDataUploader('load-stages-data', 'ステージリスト', d => Array.isArray(d) && d.every(i => i.value && i.name), async data => { 
        await saveData('stages', data);
        DEFAULT_STAGES = data;
        renderStageList(data); 
    });
    setupDataUploader('load-weapons-data', 'ブキデータ', d => Array.isArray(d), async data => { WEAPONS = data; await saveData('weapons', data); renderWeaponList(); });
    setupDataUploader('load-tiers-data', 'ティア表', d => d.area && (d.area.tierS || d.area.tierX), async data => { WEAPON_TIERS_BY_RULE = data; await saveData('tiers', data); });
    setupDataUploader('load-counters-data', 'カウンター相性', d => Array.isArray(d) && d.every(i => i.winner), async data => { COUNTER_MATCHUPS = data; await saveData('counters', data); });
    setupDataUploader('load-specials-data', 'スペシャルタグ', d => typeof d === 'object', async data => { SPECIAL_TAGS = data; await saveData('specials', data); });
    setupDataUploader('load-roles-data', '役割データ', d => Array.isArray(d) && d.every(i => i.name), async data => { ROLE_PRIORITIES = data; await saveData('roles', data); });
    
    clearSettingsButton.addEventListener('click', async () => {
        if(confirm('ブラウザに保存されたすべてのカスタムデータを削除し、初期設定に戻します。よろしいですか？')) {
            await clearDB();
            alert('設定をリセットしました。ページをリロードします。');
            location.reload();
        }
    });

    resetButton.addEventListener('click', () => {
        weaponSlots.forEach(slot => {
            slot.style.backgroundImage = 'none';
            slot.classList.remove('selected');
            const nameSpan = slot.querySelector('.weapon-name');
            if (nameSpan) nameSpan.textContent = '';
            if (!slot.classList.contains('selected')) {
                 slot.innerHTML = '+<span class="weapon-name"></span>';
            }
        });
        selectedWeapons = { 
            my: {1: null, 2: null, 3: null, 4: null}, 
            enemy: {1: null, 2: null, 3: null, 4: null} 
        };
        analysisHistory = [];
        analysisHistoryContainer.innerHTML = '';
        searchInput.value = '';
        document.getElementById('stage-select').selectedIndex = 0;
        document.getElementById('rule-select').selectedIndex = 0;
    });

    // 初期化
    renderStageList(DEFAULT_STAGES);
    renderWeaponList();
});
</script>
</body>
</html>
